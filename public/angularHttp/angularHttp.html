<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!--<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.3.0-beta.13/angular.min.js"></script>-->
  <!--<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">-->
  <link rel="stylesheet" href="../stylesheets/bootstrap-min.css">
  <link rel="stylesheet" media="all" href="../theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="../theme/css/phone.css">


  <script src="../js/jquery-1.11.1.min.js"></script>
  <script src="../js/presenter.js"></script>

  <base target="_blank">
  <style>
    code {
      color: darkblue;
    }
  </style>

  <!-- This opens all links in a new tab. -->
  <script data-main="../js/slides" src="../js/require-1.0.8.min.js"></script>

  <!--In order to have more than one slideset in the project-->
  <script src="slides.js"></script>

</head>

<!--Setup Angular for the full slide-set-->
<!--<body ng-app="SlideApp" style="opacity: 0">-->
<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground" style="background: #00163B">
    <aside class="gdbar"><img src="../images/logo.png" style="width: 200px;"></aside>
    <hgroup class="auto-fadein" style="color: white;">
      <div style="float: left;">
        <h1 data-config-title style="float:left;"></h1>

        <h2 data-config-subtitle></h2>

        <p data-config-presenter></p>
      </div>
      <div style="float:left;margin-left: 2em;"><img src="../../images/AngularLogo.png" style="float:left">
      </div>
    </hgroup>
  </slide>

  <slide>
    <hgroup>
      <h2>Promises and $http Service</h2>
    </hgroup>
    <article>
      <h3>
        Before we look into Angulars $http Service we need to understand:
      </h3>

      <p style="font-size: 100px;font-weight:bold;color:#000066;text-align: center;margin-top: 70px;">Promises</p>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>The Callback Hell</h2>
    </hgroup>
    <article>
      <p style="margin-top: -35px;">Nested Callbacks</p>
      <ul class="smaller" style="margin-top: -10px;">
        <li> Each callback needs to check if there's an error - annoying</li>
        <li>Each callback indents your code to the right. So a lot of callbacks can create a christmas tree effect</li>
      </ul>
      <p class="smaller" style="color:#000066">
        Callbacks provide no consistency and no guaranteed call, they steal code flow when depending upon other
        callbacks, and they generally make debugging incredibly difficult. At every step of the way, we have to deal
        with explicitly handling errors.
      </p>

      <div class="row" style="margin-top: -8px;">
        <div class="col-md-6">
          <p class="smaller" style="color:#000066">Callback</p>
        <pre class="prettyprint pre14" style="margin-top: -12px;">
User.get(fromId, {
  success: function(err, user) {
    if (err) return {error: err};
    user.friends.find(toId, function(err, friend) {
      if (err) return {error: err};
      user.sendMessage(friend, message, callback);
    });
  },
  failure: function(err) {
    return {error: err}
  }
});
        </pre>
        </div>
        <div class="col-md-6">
          <p class="smaller" style="color:#000066">Using Promises</p>
<pre class="prettyprint pre14" style="margin-top: -12px;">
User.get(fromId)
.then(function(user) {
  return user.friends.find(toId);
}, function(err) {
  // We couldn't find the user
})
.then(function(friend) {
  return user.sendMessage(friend, message);
}, function(err) {
  // The user's friend resulted in an error
})
.then(function(success) {
  // user was sent the message
}, function(err) {
  // An error occurred
});
</pre>
        </div>
      </div>
      <footer class="source">https://www.ng-book.com/</footer>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Why Promises</h2>
    </hgroup>
    <article>
      <ul class="smaller">
        <li>
          Promises make asynchronous functions look more like synchronous ones. With synchronous functions, we can
          capture
          both return values and exception values as expected.
        </li>
        <li>We can capture errors at any point of the process and bypass future code that relies upon the error of that
          process.
        </li>

        <li>Promises are first-class objects and carry with them a few guarantees:
          <ul>
            <li>Only one resolve or reject will ever be called</li>
            <li>resolve is called with a single fulfillment value</li>
            <li>reject can be called with a single rejection reason</li>
            <li>If the promise has been resolved or rejected, any handlers depending upon them will still be called</li>
            <li>Handlers will always be called asynchronously</li>
            <li>We can chain promises and allow the code to process as it would normally run. Exceptions from one
              promise bubble up through the entire promise chain.
            </li>
            <li>Promises are always executed asynchronously; we can use them without worry that they will block the rest
              of the
              app.
            </li>
          </ul>
      </ul>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>What is a Promise</h2>
    </hgroup>
    <article>
      <ul>
        <li>A promise is always asynchronous</li>
        <li>A promise represents a task that will finish in the future</li>
        <li>A promise expose a function (<b>then</b>)
          <ul>
            <li><b>then</b> returns a new promise</li>
            <li>allows for the attachment of handlers that will be executed based on state</li>
            <li>handlers are guaranteed to execute in order attached</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Promises Demo</h2>
    </hgroup>
    <article>
      <img src="../images/Demo.png">
      <footer class="source">https://egghead.io/lessons/angularjs-promises</footer>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Promises in Angular</h2>
    </hgroup>
    <article>
      <h3>Angular uses promises for everything that is asynchronous:</h3>
      <ul style="margin:25px;color: #000066">
        <li>$timeout;</li>
        <li>$http;</li>
        <li>$routeProvider.when;</li>
        <li>much more.</li>
      </ul>

    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Connecting to a Backend </h2>
    </hgroup>
    <article>
      <p style="margin-top: -25px;">We will connect to the backend using Angulars $http service, and with Express as the
        backend server</p>

      <p>This leaves it up to us, to handle synchronization with server, i.e we have a view, with a list of users,
        this list will only update, next time we request data from the Server</p>
      <img src="images/backendTwoWay.PNG" style="width: 60%;margin-left: 20%;">
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2 style="font-size: 44px;">Connecting to a Backend - the cool way</h2>

      <h3 style="float: left;">If we have had more time</h3>
      <img src="../images/smileyBlink.jpg" style="height: 35px;float: left;margin-top:15px;margin-left: 10px;">
    </hgroup>
    <article>
      <p style="margin-top: -35px;clear: both">What if we could have <b>three way binding</b>, that is; When data is
        updated in any
        of the three places (View, Model, or
        Backend), the changes propagate in real-time to the other two across all clients.</p>
      <img src="images/3-way-binding.png" style="width: 50%;margin-left: 25%;">

      <p class="smaller" style="color: #000066;">Using modern HTML5 related technologies like Web Sockets this is
        possible. A number of options exist to achieve
        this, with <b>Firebase</b> as the recommended way for Angular<br/>
        <em>We won't use this, this semester</em>

      <p>
        <footer class="source"><a href="https://www.firebase.com/">FireBase</a></footer>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>Communicating with the Server</h2>

      <h3>The $http Service</h3>
    </hgroup>
    <article>
      <p>The $http service is a core Angular service that facilitates communication with the remote HTTP servers via the
        browser's XMLHttpRequest object (AJAX) or via JSONP.</p>

      <p>For unit testing we can use the $httpBackend mock (next week)</p>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Using the $http Service</h2>
    </hgroup>
    <article>
    <pre class="prettyprint ">
$http({method: 'GET',
       url: '/someUrl'
      }).then(function successCallback(response) {
       // Called asynchronously when the response is available
      }, function errorCallback(response) {
       // called asynchronously if an error occurs or server returns an error status.
      }); </pre>
      <p style="margin-bottom: 0.75em;">The <b>response</b> object has these properties:</p>
      <ul style="font-size: 80%;">
        <li><strong>data</strong> – <code><span class="pun">{</span><span class="kwd">string</span><span
                class="pun">|</span><span class="typ">Object</span><span class="pun">}</span></code> – The response body
          transformed with the transform
          functions.
        </li>
        <li><strong>status</strong> – <code><span class="pun">{</span><span class="pln">number</span><span
                class="pun">}</span></code> – HTTP status code of the response.
        </li>
        <li><strong>headers</strong> – <code><span class="pun">{</span><span class="kwd">function</span><span
                class="pun">([</span><span class="pln">headerName</span><span class="pun">])}</span></code> – Header
          getter function.
        </li>
        <li><strong>config</strong> – <code><span class="pun">{</span><span class="typ">Object</span><span
                class="pun">}</span></code> – The configuration object that was used to generate the request.
        </li>
        <li><strong>statusText</strong> – <code><span class="pun">{</span><span class="kwd">string</span><span
                class="pun">}</span></code> – HTTP status text of the response.
        </li>
      </ul>
      <p>Later we will se how Angular offers a$httpBackend mock, which allows us to test http-requests without a
        backend</p>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Shortcut methods</h2>
    </hgroup>
    <article>
    <pre class="prettyprint">
$http.get('/someUrl', config).then(successCallback, errorCallback);
$http.post('/someUrl', data, config).then(successCallback, errorCallback);
    </pre>
      <p>Complete list of shortcut methods:</p>
      <ul>
        <li>$http.get</li>
        <li>$http.get</li>
        <li>$http.head</li>
        <li>$http.post</li>
        <li>$http.put</li>
        <li>$http.delete</li>
        <li>$http.jsonp</li>
        <li>$http.patch</li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Angular with Backend Demo</h2>

      <h3>Angular with REST (JAX-RS)</h3>
    </hgroup>
    <article>

      </p>
      <img src="../images/Demo.png">
      <p>Clone/Fork this project unless you have it from this monday</p>
      <h1><a href="https://github.com/Lars-m/angularday1.git">https://github.com/Lars-m/angularday1.git</a></h1>

    </article>
  </slide>

  <slide class="nobackground" style="background: #00163B">
    <aside class="gdbar right"><img src="../images/logo.png" style="width: 200px;"></aside>
    <hgroup>

    </hgroup>
    <article class="flexbox  auto-fadein" style="margin-top: 25%;">
      <h2>Rest of today; Exercises :-)</h2>

    </article>
    <p class="auto-fadein" data-config-contact>
      <!-- populated from slide_config.json -->
    </p>
  </slide>


  <slide class="backdrop"></slide>

</slides>

<script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
  _gaq.push(['_trackPageview']);

  (function () {
    var ga = document.createElement('script');
    ga.type = 'text/javascript';
    ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--[if IE]>
<script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
<script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
